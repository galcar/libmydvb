
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mydvb_txt.h"

static unsigned char _mydvb_txt_reverse[] = {
	0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,
	0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
	0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,
	0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
	0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,
	0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
	0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,
	0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
	0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,
	0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
	0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,
	0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
	0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,
	0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
	0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,
	0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
	0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,
	0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
	0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,
	0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
	0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,
	0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
	0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,
	0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
	0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,
	0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
	0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,
	0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
	0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,
	0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
	0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,
	0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF
};

static unsigned char _mydvb_unhamtab[256] = {
  0x01, 0xff, 0x81, 0x01, 0xff, 0x00, 0x01, 0xff,
  0xff, 0x02, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x07,
  0xff, 0x00, 0x01, 0xff, 0x00, 0x80, 0xff, 0x00,
  0x06, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x03, 0xff,
  0xff, 0x0c, 0x01, 0xff, 0x04, 0xff, 0xff, 0x07,
  0x06, 0xff, 0xff, 0x07, 0xff, 0x07, 0x07, 0x87,
  0x06, 0xff, 0xff, 0x05, 0xff, 0x00, 0x0d, 0xff,
  0x86, 0x06, 0x06, 0xff, 0x06, 0xff, 0xff, 0x07,
  0xff, 0x02, 0x01, 0xff, 0x04, 0xff, 0xff, 0x09,
  0x02, 0x82, 0xff, 0x02, 0xff, 0x02, 0x03, 0xff,
  0x08, 0xff, 0xff, 0x05, 0xff, 0x00, 0x03, 0xff,
  0xff, 0x02, 0x03, 0xff, 0x03, 0xff, 0x83, 0x03,
  0x04, 0xff, 0xff, 0x05, 0x84, 0x04, 0x04, 0xff,
  0xff, 0x02, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x07,
  0xff, 0x05, 0x05, 0x85, 0x04, 0xff, 0xff, 0x05,
  0x06, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x03, 0xff,
  0xff, 0x0c, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x09,
  0x0a, 0xff, 0xff, 0x0b, 0x8a, 0x0a, 0x0a, 0xff,
  0x08, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x0d, 0xff,
  0xff, 0x0b, 0x0b, 0x8b, 0x0a, 0xff, 0xff, 0x0b,
  0x0c, 0x8c, 0xff, 0x0c, 0xff, 0x0c, 0x0d, 0xff,
  0xff, 0x0c, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x07,
  0xff, 0x0c, 0x0d, 0xff, 0x0d, 0xff, 0x8d, 0x0d,
  0x06, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x0d, 0xff,
  0x08, 0xff, 0xff, 0x09, 0xff, 0x09, 0x09, 0x89,
  0xff, 0x02, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x09,
  0x88, 0x08, 0x08, 0xff, 0x08, 0xff, 0xff, 0x09,
  0x08, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x03, 0xff,
  0xff, 0x0c, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x09,
  0x0f, 0xff, 0x8f, 0x0f, 0xff, 0x0e, 0x0f, 0xff,
  0x08, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x0d, 0xff,
  0xff, 0x0e, 0x0f, 0xff, 0x0e, 0x8e, 0xff, 0x0e,
};

static unsigned char _mydvb_unham (unsigned char a, unsigned char b) {

	unsigned char c1, c2;

	c1 = _mydvb_unhamtab[a];
	c2 = _mydvb_unhamtab[b];
	//if( (c1 | c2) & 0x40) fprintf(stderr, "jpvtx: bad ham!");

	return (c2 << 4) | (0x0f & c1);
}

unsigned char mydvb_txt_get_char (unsigned char c, int lang) {
//	if (lang==0) {
//		return _mydvb_txt_lang_spanish[c];
//	} else {
		return c;
//	}
}

void mydvb_txt_init (MYDVB_TELETEXT *txt) {

	memset (txt->header.data, '*', 40);
	
	txt->paginas_len = 0;
	txt->paginas = NULL;

	txt->current_page = NULL;

	txt->page_ready_callback = NULL;
	txt->data_page_ready = NULL;

	txt->first_line_callback = NULL;
	txt->data_first_line = NULL;

/*
	for (i=0; i < 2048; i++) {
		mydvb_txt_init_page (&txt->paginas[i]);
	}
*/
}

void mydvb_txt_end (MYDVB_TELETEXT *txt) {
	int i;
	MYDVB_TELETEXT_PAGE *page = NULL;

	if (txt==NULL) {
		return;
	}

	for (i=0; i < txt->paginas_len; i++) {
		page = (MYDVB_TELETEXT_PAGE *) txt->paginas[i];
		if (page!=NULL) {
			mydvb_txt_page_free (page);
		}
	}
	free (txt->paginas);
	txt->paginas = NULL;
	txt->paginas_len = 0;

	txt->current_page = NULL;

	txt->page_ready_callback = NULL;
	txt->data_page_ready = NULL;

	txt->first_line_callback = NULL;
	txt->data_first_line = NULL;
}

MYDVB_TELETEXT_PAGE *mydvb_txt_find (MYDVB_TELETEXT *txt, int number) {
	int i;
	MYDVB_TELETEXT_PAGE *page = NULL;

	for (i=0; i < txt->paginas_len; i++) {
		page = (MYDVB_TELETEXT_PAGE *) txt->paginas[i];
		if ((page->magazine * 256 + page->page_number) == number) {
			// encontrado
			return page;
		}
	}

	return NULL;

}

void mydvb_txt_add_page (MYDVB_TELETEXT *txt, MYDVB_TELETEXT_PAGE *page) {
	if (txt==NULL || page==NULL) {
		return;
	}

	if (txt->paginas_len==0) {
		txt->paginas = (MYDVB_TELETEXT_PAGE **) malloc (sizeof(MYDVB_TELETEXT_PAGE*));
	} else {
		txt->paginas = (MYDVB_TELETEXT_PAGE **) realloc (txt->paginas, sizeof (MYDVB_TELETEXT_PAGE*) * (txt->paginas_len+1));
	}
	txt->paginas[txt->paginas_len] = page;
	txt->paginas_len ++;

}

MYDVB_TELETEXT_PAGE *mydvb_txt_page_new () {
	MYDVB_TELETEXT_PAGE *page = NULL;

	page = (MYDVB_TELETEXT_PAGE *) malloc (sizeof(MYDVB_TELETEXT_PAGE));

	mydvb_txt_page_init (page, 0, 0);

	return page;
}

void mydvb_txt_page_init (MYDVB_TELETEXT_PAGE *page, int magazine, int page_number) {

	page->magazine = magazine;
	page->page_number = page_number;
	page->sub_page = 0;
	page->ready = 0;

	memset (page->data, ' ', 24*40);
	memset (page->active_lines, 0, 24);

}

void mydvb_txt_page_free (MYDVB_TELETEXT_PAGE *page) {
	if (page == NULL) {
		return;
	}

	free (page);
}

void mydvb_decode_teletext (MYDVB_TELETEXT *txt, unsigned char *buf, int requested_page) {

	unsigned char header, magazine, packet;
	unsigned char f1, f2, f3, f4;
	MYDVB_TELETEXT_PAGE *page = NULL;

	// buf[0] should be 02
	if (buf[1] != 44) {
		/* fprintf(stderr, "error: VBI line has invalid length\n");*/
		return;
	}

	/* bit twiddling */
	mydvb_txt_dec_reverse (buf+2, 4); // 44
/*
	for (i = 2; i < 46; i++) {
		buf[i] = _mydvb_txt_reverse[buf[i]];
	}
*/
	/* framing code, should be 11100100b */
	if (buf[3] != 0x27) {
        //fprintf(stderr, "error: wrong framing code\n");
		return;
    }

	header = _mydvb_unham (buf[4], buf[5]);
	magazine = header & 7;
	packet   = (header >> 3) & 0x1f;

	if (packet == 0) { // packet number 
		// this is a new page so flush current page
		// call page ready event handler
		if (txt->current_page != NULL && txt->page_ready_callback != NULL) {
			txt->current_page->ready = 1;
			txt->page_ready_callback (txt->current_page, txt->data_page_ready);
		}

		/* decode the header */
		mydvb_txt_dec_reverse (buf+6, 8);

		f1 = _mydvb_unham (buf[6], buf[7]);  // page number in a magazine de 0x00 a 0xff
		f2 = _mydvb_unham (buf[8], buf[9]);  // subpage + c4
		f3 = _mydvb_unham (buf[10], buf[11]);// subpage + c5 + c6
		f4 = _mydvb_unham (buf[12], buf[13]);
		// printf ("Page number: %.2X %.2X %.2X %.2X\n", f1, f2, f3, f4);

		txt->header.erase		= (f2 & 0x80) >> 7;
		txt->header.newflash 	= (f3 & 0x40) >> 6;
		txt->header.subtitle 	= (f3 & 0x80) >> 7;
		txt->header.no_header	= (f4 & 0x01);
		txt->header.update		= (f4 & 0x02) >> 1;
		txt->header.no_sequence	= (f4 & 0x04) >> 2;
		txt->header.no_display	= (f4 & 0x08) >> 3;
		txt->header.serial		= (f4 & 0x80) >> 7;
		memcpy (txt->header.data + 8, buf + 14, 32); // reserve first three 

		/* show the first line, if needed */
		if (txt->first_line_callback != NULL) {
			txt->first_line_callback (txt, txt->data_first_line);
		}

		/* work with page */		
		if (requested_page == (magazine*256+f1)) {
			page = mydvb_txt_find (txt, requested_page);
			if (page==NULL) {
				// no encontrado
				page = mydvb_txt_page_new ();
				page->magazine = magazine;
				page->page_number = f1;
				mydvb_txt_add_page (txt, page);
			} else {
				mydvb_txt_page_init (page, magazine, f1);
			}
			txt->current_page = page;
		} else {
			txt->current_page = NULL;
		}

		/*
		if (txt->header.erase) {
			mydvb_txt_erase_page (&txt->paginas[txt->current_page]);
		}
		*/
	} else if (packet >= 1 && packet <= 24) {
		if (txt->current_page != NULL) {
			memcpy (txt->current_page->data[packet-1], buf + 6, 40);
			txt->current_page->active_lines[packet-1]=1;
		}
	} else if (packet == 27) {
/*
		if (txt->current_page != NULL) {
			int mgz;
			mydvb_txt_dec_reverse (buf+6, 40);
			printf ("Designation code: %X\n", _mydvb_unhamtab[buf[6]]);
			f1 = _mydvb_unham (buf[7], buf[8]);  // page number in a magazine de 0x00 a 0xff
			f2 = _mydvb_unham (buf[9], buf[10]); // subpage + m1
			f3 = _mydvb_unham (buf[11], buf[12]);// subpage + m2 + m3
			mgz = ((f2 & 0x80) >> 5)  | ((f3 & 0x40) >> 6) | ((f3 & 0x80) >> 7);
			printf ("Link to %X, %X, %X, %X\n", magazine ^ mgz, f1, f2 & 0x7f, f3 & 0x3f);
			printf ("%d%d%d\n", (f2 & 0x80) >> 7, (f3 & 0x40) >> 7, (f3 & 0x80) >> 7);

			f1 = _mydvb_unham (buf[13], buf[14]);  // page number in a magazine de 0x00 a 0xff
			f2 = _mydvb_unham (buf[15], buf[16]);  // subpage + m1
			f3 = _mydvb_unham (buf[17], buf[18]);// subpage + m2 + m3
			mgz = ((f2 & 0x80) >> 5)  | ((f3 & 0x40) >> 6) | ((f3 & 0x80) >> 7);
			printf ("Link to %X, %X, %X, %X\n", magazine ^ mgz, f1, f2 & 0x7f, f3 & 0x3f);
			printf ("%d%d%d\n", (f2 & 0x80) >> 7, (f3 & 0x40) >> 7, (f3 & 0x80) >> 7);

			f1 = _mydvb_unham (buf[19], buf[20]);  // page number in a magazine de 0x00 a 0xff
			f2 = _mydvb_unham (buf[21], buf[22]);  // subpage + m1
			f3 = _mydvb_unham (buf[23], buf[24]);// subpage + m2 + m3
			mgz = ((f2 & 0x80) >> 5)  | ((f3 & 0x40) >> 6) | ((f3 & 0x80) >> 7);
			printf ("Link to %X, %X, %X, %X\n", magazine ^ mgz, f1, f2 & 0x7f, f3 & 0x3f);
			printf ("%d%d%d\n", (f2 & 0x80) >> 7, (f3 & 0x40) >> 7, (f3 & 0x80) >> 7);

			f1 = _mydvb_unham (buf[25], buf[26]);  // page number in a magazine de 0x00 a 0xff
			f2 = _mydvb_unham (buf[27], buf[28]);  // subpage + m1
			f3 = _mydvb_unham (buf[29], buf[30]);// subpage + m2 + m3
			mgz = ((f2 & 0x80) >> 5)  | ((f3 & 0x40) >> 6) | ((f3 & 0x80) >> 7);
			printf ("Link to %X, %X, %X, %X\n", magazine ^ mgz, f1, f2 & 0x7f, f3 & 0x3f);
			printf ("%d%d%d\n", (f2 & 0x80) >> 7, (f3 & 0x40) >> 7, (f3 & 0x80) >> 7);

		}
*/
	}

}

void mydvb_txt_dec_reverse (unsigned char *buf, size_t n) {
	int i;

	if (buf==NULL) {
		return;
	}

	for (i=0; i < n; i++) {
		buf[i] = _mydvb_txt_reverse[buf[i]];
	}
}

void mydvb_txt_erase_page (MYDVB_TELETEXT_PAGE *page) {
	memset (page->data, 0, 24*40);		
}

void mydvb_txt_print_page (MYDVB_TELETEXT_PAGE *page) {
	int i;

	for (i=1; i <= 24; i++) {
		mydvb_txt_print_row (page->data[i]);
		printf ("\n");
	}
}

void mydvb_txt_print_row (unsigned char *buf) {
	int j;

	for (j=0; j < 40; j++) {
			printf ("%X ", buf[j] & 0x7f);
	}
}
